/*
 Navicat Premium Data Transfer

 Source Server         : 123
 Source Server Type    : MySQL
 Source Server Version : 80011
 Source Host           : localhost:3306
 Source Schema         : shejimoshi

 Target Server Type    : MySQL
 Target Server Version : 80011
 File Encoding         : 65001

 Date: 10/07/2018 16:40:55
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for main
-- ----------------------------
DROP TABLE IF EXISTS `main`;
CREATE TABLE `main`  (
  `id` int(2) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `define` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `nature` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `when` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `solve` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `exam` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `good` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `bad` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `position` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 27 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of main
-- ----------------------------
INSERT INTO `main` VALUES (1, '简单工厂模式', '在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。', '选择实现', '我们明确地计划不同条件下创建不同实例时。', '主要解决接口选择的问题。', '计算器\r\n运算工厂\r\n', '1、一个调用者想创建一个对象，只要知道其名称就可以了。 <br>\r\n2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。<br>\r\n3、屏蔽产品的具体实现，调用者只关心产品的接口。', '每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。', '1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 <br>\r\n2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 <br>\r\n3、设计一个连接服务器的框架，需要三个协议，\"POP3\"、\"IMAP\"、\"HTTP\"，可以把这三个作为产品类，共同实现一个接口。');
INSERT INTO `main` VALUES (2, '策略模式', '他定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到用算法的客户。或者如下定义：在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。', '分离算法，选择实现', '一个系统有许多许多类，而区分它们的只是他们直接的行为。', '在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。', '《三国演义》中的故事\r\n诸葛亮的锦囊妙计<br>三条妙计\r\n:<br>走乔国老的后门，求孙国太放人，请孙夫人退兵<br>\r\n赵云按计行事\r\n环境角色：赵云 由他来决定选择策略\r\n抽象策略角色：(接口)锦囊妙计按计行事（抽象方法）\r\n具体策略角色：三条妙计(单独使用的)\r\n', '1、算法可以自由切换。<br />\r\n2、避免使用多重条件判断。<br />\r\n3、扩展性良好。', '1、策略类会增多,增加了对象的数目。<br />\r\n2、所有策略类都需要对外暴露。<br />\r\n3、只适合扁平的算法结构。', '1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。<br />\r\n2、一个系统需要动态地在几种算法中选择一种。<br />\r\n3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。');
INSERT INTO `main` VALUES (3, '装饰模式', '动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。<br />\r\n装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。	', '动态组合：动态是手段，组合是目的', '在不想增加很多子类的情况下扩展类。', '一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。', '1. 穿衣搭配<br>\r\n2. 咖啡制作\r\n', '1.比继承更灵活<br>\r\n2.创造出许多不同类型的对象', '1.会出产生很多细粒度对象', '1、扩展一个类的功能。<br />\r\n2、动态增加功能，动态撤销。');
INSERT INTO `main` VALUES (4, '代理模式', '为其他对象提供一种代理以控制对这个对象的访问。', '控制对象访问', '想在访问一个类时做一些控制。', '增加中间层。', '1、Windows 里面的快捷方式。<br> 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。<br> 3、买火车票不一定在火车站买，也可以去代售点。<br> 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。<br> 5、spring aop。', ' 1、职责清晰。 <br>2、高扩展性。<br> 3、智能化。', '1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。<br> 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 ', '按职责来划分，通常有以下使用场景： <br>1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。 ');
INSERT INTO `main` VALUES (5, '工厂方法模式', '定义一个创建产品对象的工厂接口，让子类决定实例化哪一个类，将实际创建工作推迟到子类当中。', '延迟到子类来选择实现\r', '1)当客户程序不需要知道要使用对象的创建过程。<br>\r\n2)客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象', '当简单工厂模式增加一种功能时，需要修改case语句，这样既对扩展开放又对修改开放，违背了开放封闭原则，这时便需要用到工厂方法模式，', '汽车由发动机、轮、底盘组成，现在需要组装一辆车交给调用者。', '（1）良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要\r\n知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。<br>\r\n（2）工厂方法模式的扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，\r\n就可以完成“拥抱变化”。<br>\r\n（3）屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，\r\n只要接口保持不变，系统中的上层模块就不要发生变化。因为产品类的实例化工作是由工厂类负责的，一个产品对象\r\n具体由哪一个产品生成是由工厂类决定的。', '在某种程度上违背了开放--封闭原则<br>\r\n对工厂类过于依赖\r\n', '首先，工厂方法模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用，但是需要慎重地考\r\n虑是否要增加一个工厂类进行管理，增加代码的复杂度。');
INSERT INTO `main` VALUES (6, '原型模式', '用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。', '克隆生成对象', '1、当一个系统应该独立于它的产品创建，构成和表示时。 <br>2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。<br> 3、为了避免创建一个与产品类层次平行的工厂类层次时。<br> 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。', '在运行期建立和删除原型。', '1、细胞分裂。 <br>2、JAVA 中的 Object clone() 方法。 ', '(1) 原型模式允许动态添加或减少产品类。<br>\r\n(2) 原型模式提供了简化的创建结构。', '每个原型的子类都必须实现Clone的操作，尤其在包含引用类型的对象时，clone方法会比较麻烦，必须要能够递归地址。', ' 1、资源优化场景。 <br>2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 <br>3、性能和安全要求的场景。<br> 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。<br> 5、一个对象多个修改者的场景。<br> 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。<br> 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。 ');
INSERT INTO `main` VALUES (7, '模板方法模式', '定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。', '将某些基本方法汇集起来的模式', '有一些通用的方法', '将这些通用算法抽象出来。', '1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。<br> 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。<br> 3、Spirng 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。', '实现代码复用', '算法骨架不容易升级\r\n', '1、有多个子类共有的方法，且逻辑相同。<br> 2、重要的、复杂的方法，可以考虑作为模板方法。');
INSERT INTO `main` VALUES (8, '外观模式', '为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。', NULL, '1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个\"接待员\"即可。<br> 2、定义系统的入口。 ', '客户端不与系统耦合，外观类与系统耦合。', NULL, '1、减少系统相互依赖。<br> 2、提高灵活性。<br> 3、提高了安全性。 ', '不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。', '1、为一个复杂的子系统提供一个简单接口时。<br>\r\n2、当客户程序为抽象类的实现部分之间存在较大的依赖性时。');
INSERT INTO `main` VALUES (9, '建造者模式', '将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示', '分离整体构建、算法和部件构造\r\n', '主要解决在软件系统中，有时候面临着\"一个复杂对象\"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。一些基本部件不会变，而其组合经常变化的时候。', '将变与不变分离开。', ' 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的\"套餐\"。<br> 2、JAVA 中的 StringBuilder。 ', '1、建造者独立，易扩展。<br> 2、便于控制细节风险。 ', ' 1、产品必须有共同点，范围有限制。 <br>2、如内部变化复杂，会有很多的建造类。', '1、需要生成的对象具有复杂的内部结构。 <br>2、需要生成的对象内部属性本身相互依赖。 ');
INSERT INTO `main` VALUES (10, '观察者模式', '定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。', '触发联动', '一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。', '一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。', '1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。<br>2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。 ', '1、观察者模式实现了观察者和目标之间的抽象耦合。<br>\r\n2、观察者模式实现了动态联动观察者模式支持广播通信。<br>\r\n3、被观察者会向所有的登记过的观察者发出通知。', '可能会引起无谓的操作。\r由于采用广播方式，不管观察者需不需要，每个观察者都会被调用update方法\r', '1、有多个子类共有的方法，且逻辑相同。 <br>\r\n2、重要的、复杂的方法，可以考虑作为模板方法。');
INSERT INTO `main` VALUES (11, '抽象工厂模式', '提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。', '选择产品族的实现', '系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。<br>\r\n希望一个系统不应当依赖于产品类实例如何被创建，组合和表达的细节时', '主要解决接口选择的问题。', '工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。', '当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。', '产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。', '1、QQ 换皮肤，一整套一起换。<br> \r\n2、生成不同操作系统的程序。 ');
INSERT INTO `main` VALUES (12, '状态模式', '允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。', '根据状态分离和选择行为，状态驱动，由上下文负责', '代码中包含大量与对象状态有关的条件语句。', '对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。', ' 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。<br> 2、曾侯乙编钟中，\'钟是抽象接口\',\'钟A\'等是具体状态，\'曾侯乙编钟\'是具体环境（Context）。', '1、封装了转换规则。<br> 2、枚举可能的状态，在枚举状态之前需要确定状态种类。<br> 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。<br> 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 <br>5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数', '逻辑分散，状态逻辑分布到了很多的state子类中', '1、行为随状态改变而改变的场景。<br>\r\n 2、条件、分支语句的代替者。');
INSERT INTO `main` VALUES (13, '适配器模式', '将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。', '转换匹配，复用功能', '1、系统需要使用现有的类，而此类的接口不符合系统的需要。<br> 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。<br> 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） ', '主要解决在软件系统中，常常要将一些\"现存的对象\"放到新的环境中，而新环境要求的接口是现对象不能满足的。', '1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。<br> 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。<br> 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。 ', '1. 更好的复用性。<br>\r\n2. 更好的可扩展性。', '过多的使用适配器，会使系统非常的凌乱，不容易整体把握。', '有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。');
INSERT INTO `main` VALUES (14, '备忘录模式', '在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。', '保存和恢复', '很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有\"后悔药\"可吃。', '所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。', '1、后悔药。<br > 2、打游戏时的存档。<br> 3、Windows 里的 ctri + z。<br> 4、IE 中的后退。<br> 5、数据库的事务管理。 ', '1、较好地保持了封装的边界。<br>\r\n2、简化了发起人类。<br>\r\n3、能进行状态的复原。', '消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存', '1、需要保存/恢复数据的相关状态场景。<br> 2、提供一个可回滚的操作。 ');
INSERT INTO `main` VALUES (15, '组合模式', '将对象组合成树形结构以表示\"部分-整体\"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。', '统一了叶子对象和组合对象', '1、您想表示对象的部分-整体层次结构（树形结构）。<br> 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 ', '它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。', '1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。 <br>2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。 ', '定义了包含基本对象和组合对象的类层，统一了组合对象和叶子对象，简化了客户端调用。', '在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。', '部分、整体场景，如树形菜单，文件、文件夹的管理。');
INSERT INTO `main` VALUES (16, '迭代器模式', '提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。', NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `main` VALUES (17, '单例模式', '保证一个类仅有一个实例，并提供一个访问它的全局访问点。', '控制实例数目\r', '当您想控制实例数目，节省系统资源的时候。', '一个全局使用的类频繁地创建与销毁。', '1、一个党只能有一个主席。<br>. 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。<br> 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。 ', '1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。<br> 2、避免对资源的多重占用（比如写文件操作）。', '没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。', '1、要求生产唯一序列号。<br> 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。<br> 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。');
INSERT INTO `main` VALUES (18, '桥接模式', '将抽象部分与他的实现部分分离，是他们都可以独立的变化。', '分离抽象和实现。', '实现系统可能有多个角度分类，每一种角度都可能变化。', '在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。', '<p>1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。<br> 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。', '1、抽象和实现的分离。<br> 2、优秀的扩展能力。<br> 3、实现细节对客户透明。', '<p>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。', '<p>1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。<p> 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 ');
INSERT INTO `main` VALUES (19, '命令模式', '将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。', '封装请求', '在某些场合，比如要对行为进行\"记录、撤销/重做、事务\"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\"行为请求者\"与\"行为实现者\"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。', '在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。', 'struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。', '1、命令模式使新的命令很容易地被加入到系统里。<br> 2、\r允许接收请求的一方决定是否要否决（Veto）请求。<br>3、 \r能较容易地设计一个命令队列。<br>4、 \r可以容易地实现对请求的Undo和Redo。<br>4、 \r在需要的情况下，可以较容易地将命令记入日志。<br>5、 \r命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。<br> 6、\r命令类与其他任何别的类一样，可以修改和推广。', '使用命令模式可能会导致某些系统有过多的具体命令类。', '认为是命令的地方都可以使用命令模式，比如： <br>1、GUI 中每一个按钮都是一条命令。<br> 2、模拟 CMD。 ');
INSERT INTO `main` VALUES (20, '职责链模式', '避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。', '分离职责，动态组合', '在处理消息的时候以过滤很多道。', '职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。', '1、红楼梦中的\"击鼓传花\"。<br>2、JS 中的事件冒泡。<br> 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。 ', ' 1、降低耦合度。它将请求的发送者和接收者解耦。 <br>2、简化了对象。使得对象不需要知道链的结构。 <br>3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。<br> 4、增加新的请求处理类很方便。', '1、不能保证请求一定被接收。<br> 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 <br>3、可能不容易观察运行时的特征，有碍于除错。 ', ' 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。<br> 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。<br> 3、可动态指定一组对象处理请求。 ');
INSERT INTO `main` VALUES (21, '中介者模式', '用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。', '封装交互', '多个类相互耦合，形成了网状结构。', '对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。', '1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。<br> 2、机场调度系统。<br> 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。', '1、把多对多变为一对多，减小复杂性\r\n2、终结者获得系统解伪属性。\r\n3、控制集中 ，便于管理。', '中介者会庞大，变得复杂难以维护。', '1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。<br> 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 ');
INSERT INTO `main` VALUES (22, '享元模式', '运用共享技术有效地支持大量细粒度的对象。', '分离与共享', ' 1、系统中有大量对象。<br>2、这些对象消耗大量内存。<br> 3、这些对象的状态大部分可以外部化。<br> 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。<br> 5、系统不依赖于这些对象身份，这些对象是不可分辨的。', '用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。', ' 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。<br> 2、数据库的数据池。', '大大减少对象的创建，降低系统的内存，使效率提高。', '提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。', '1、系统有大量相似对象。<br> 2、需要缓冲池的场景。 ');
INSERT INTO `main` VALUES (23, '解释器模式', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO `main` VALUES (24, '访问者模式', '表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变类的前提下定义作用于这些元素的操作。', '预留通路，回调实现', '需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，使用访问者模式将这些封装到类中。', '稳定的数据结构和易变的操作耦合问题。', '您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。', '1、访问者模式使得增加新的操作变得很容易。增加新的操作就意味着增加一个新的访问者类。<br>2、 \r访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。 \r', '1、增加新的节点类变得很困难。每增加一个新的节点都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作。<br> \r2、破坏封装。访问者模式要求访问者对象访问并调用每一个节点对象的操作，这隐含了一个对所有节点对象的要求：它们必须暴露一些自己的操作和内部状态。\r', ' 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。<br> 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，也不希望在增加新操作时修改这些类。');
INSERT INTO `main` VALUES (25, '过滤器模式', '你表弟送凤凰共患难的i', '集散地哦分', 'ui推一推', 'iok结婚i哦于i', '的分析结果i就', '还是dog还是dior哈根达斯', '吃饭胡椒粉体哦好', 'i改口了回家上帝如果还s');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `username` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `password` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('shao', '123');
INSERT INTO `user` VALUES ('s', '123');

SET FOREIGN_KEY_CHECKS = 1;
